# Skill: PTU Session Helper Dev

You are the implementation worker for the Pokemon TTRPG Session Helper project. You write code, fix bugs, and execute plans provided by your senior dev reviewer.

## Project Context

- **Stack:** Nuxt 3 SPA, SQLite + Prisma, Pinia stores, WebSocket sync
- **Views:** GM (`/gm`), Group (`/group`), Player (`/player`)
- **Components:** Auto-imported, organized by domain
- **Styling:** SCSS with global variables (`app/assets/scss/_variables.scss`)
- **Icons:** Phosphor Icons (`@phosphor-icons/vue`) — never use emojis in UI
- **Plans:** Check `docs/` for implementation plans before starting work

## Ecosystem Role

This skill is part of the 9-skill PTU testing ecosystem. You operate in the **Dev Loop** — you receive bug reports from the testing pipeline and implement fixes.

- **Bug reports** live in `app/tests/e2e/artifacts/reports/bug-*.md`. Read them for root cause analysis, affected files, and PTU rule references.
- **After fixing a bug**, update the bug report's "Fix Log" section with the commit hash and files changed.
- **The Orchestrator** (in another terminal) tells the user which bug to send you next. Follow priority: CRITICAL first, then HIGH, then MEDIUM.
- **After your fix is reviewed** (by Senior Reviewer + Game Logic Reviewer), the Playtester re-runs the affected scenario to verify.
- See `ptu-skills-ecosystem.md` for the full pipeline architecture.

## Working Rules

1. **Read before writing.** Always read the file before editing. Read the plan before executing.
2. **Small commits.** One logical change per commit. Don't batch.
3. **Immutability.** Never mutate reactive objects. Always spread/map to create new references.
4. **File size.** 800 lines max. Extract components if approaching the limit.
5. **Error handling.** Never swallow errors silently. Use `alert()` with specific messages per operation.
6. **No AI attribution.** No Co-Authored-By lines. No mentions of AI in commits or code.

## Debugging Protocol

**CRITICAL: Follow this order every time. Do not skip steps.**

1. **Check the browser console first (F12).** Import errors, runtime exceptions, and failed network requests show here. This is always step 1.
2. **Try direct navigation.** Type the URL in the address bar. If the page 500s, the error message tells you exactly what's wrong.
3. **Clear `.nuxt` build cache** when fixing compile-time errors (SCSS variables, bad imports). Run: `rm -rf app/.nuxt && cd app && npx nuxi prepare && npm run dev`
4. **Only then** investigate CSS, markup, routing config, middleware, etc.

Do NOT spend time on structural investigations (route configs, middleware, NuxtLink markup) before checking the console and trying direct navigation.

## Lessons Learned

### SCSS Variables
- Use `$color-danger`, NOT `$color-error` — the latter doesn't exist
- Always check `app/assets/scss/_variables.scss` for available variables
- When fixing a variable name, **grep the entire `app/` directory** for other occurrences — mistakes propagate during component extraction

### Phosphor Icons
- Always verify icon export names exist before using them
- `PhPaw` does NOT exist — use `PhPawPrint`
- After fixing a bad icon name, grep all files for other non-existent imports:
  ```bash
  grep -rn "from '@phosphor-icons/vue'" app/ | grep -oP 'Ph\w+' | sort -u
  ```
  Then validate each one exists in the package.

### Build Cache
- Nuxt caches compiled routes in `.nuxt/`. If a page had a compile error (bad SCSS variable, bad import), fixing the source is not enough — the stale cache persists through simple server restarts.
- Always clear `.nuxt` after fixing compile-time errors.

### WebSocket Event Handling
- The server API endpoints broadcast events via `broadcastToGroup()` in `app/server/utils/websocket.ts`.
- The client composable `app/composables/useGroupViewWebSocket.ts` routes events to Pinia store handlers.
- **Every server broadcast must have a matching composable case AND store handler.** If you add a new API endpoint that broadcasts, wire the full chain: server → composable → store.
- When debugging "group view doesn't update," build a table of server broadcasts vs composable handlers to find gaps.
- Watch for data shape mismatches: the server might send `{ sceneId, positions: { ... } }` but the store handler might expect `{ pokemon, characters, groups }` at the top level. Always verify what the server actually sends.

### Cross-Tab Sync
- Use `BroadcastChannel` API for cross-tab communication (same browser, same origin).
- Watch synchronous state (`activeSceneId`) not async state (`activeScene` from a fetch). Async watchers may fire too late or not at all.
- `$fetch`/`ofetch` does NOT reliably support `cache: 'no-store'`. Use timestamp query params (`?_t=${Date.now()}`) for cache busting instead.
- Guard `.map()` calls on store arrays that may not be populated in all contexts. The editor never calls `fetchScenes()`, so `store.scenes` is empty there.

### Drag & Drop UX
- Always add `user-select: none` to any container that supports drag operations. Text selection during drag is unacceptable.
- Always call `event.preventDefault()` at the top of `mousedown` handlers for custom drag. Without it, the browser's native image drag fires on `<img>` elements, hijacking `mousemove` events away from `document` listeners.
- Use CSS `transform: translate()` for visual feedback during drag, commit positions immutably on mouseup.
- When dragging a group, move all member sprites by the same delta (both visually during drag and in data on mouseup).

### Scene System — Deferred Features
- **Terrain & Modifiers** were removed from the scene UI (Feb 2026) for future re-implementation
- DB columns (`Scene.terrains`, `Scene.modifiers`), API serialization, and store types (`SceneModifier` interface in `groupViewTabs.ts`) are **still intact**
- Reference doc: `docs/SCENE_FUTURE_FEATURES.md` — read this before re-implementing, it has data shapes and affected file locations
- VTT grid terrain painter (encounter system) is completely separate and untouched

### Pokemon Generation (IMPORTANT — Feb 2026 refactor)
- **All Pokemon creation MUST go through** `app/server/services/pokemon-generator.service.ts` — never write inline stat calculation or `prisma.pokemon.create()` in endpoints
- Functions: `generatePokemonData()` (pure data), `createPokemonRecord()` (DB write), `generateAndCreatePokemon()` (both), `buildPokemonCombatant()` (encounter combatant wrapper)
- `origin` field on all Pokemon: `'manual' | 'wild' | 'template' | 'import' | 'captured'` — always set it
- `isInLibrary` is an **archive flag** now (false = archived/hidden), NOT "permanent vs temporary"
- PTU HP formula: `level + (baseHp * 3) + 10` — never use `baseHp + level * 2`
- Evasions use **calculated stats** (base + level-up points), not base stats
- Template load uses `overrideMoves`/`overrideAbilities` params to preserve saved movesets — if touching template save (`from-encounter.post.ts`), verify the data shapes round-trip correctly through load
- Capture (`attempt.post.ts`) auto-links `ownerId` AND sets `origin: 'captured'`
- Bulk actions (`bulk-action.post.ts`) check active encounters for BOTH archive and delete

### Prisma Migrations
- `npx prisma migrate dev` does NOT work in non-interactive terminals (Claude Code). Use `npx prisma db push` instead for schema changes, then write a separate backfill script if data migration is needed.

### General Patterns
- When a bug appears in one file, **always check if the same bug exists in related files** (extracted components, copied patterns). Don't fix one instance and call it done.
- When a NuxtLink "does nothing," it almost always means the target page has a compile or import error — not a routing/CSS/markup problem.

### Feature Completeness: Always Consider Both Entity Types
- HumanCharacter and Pokemon are the two primary entity types. They share the same sheets page, card components, and store patterns.
- **When adding a field or feature to one, ask: does the other need it too?** Example: adding `location` to HumanCharacter and grouping NPCs by location on sheets — Pokemon also needed a `location` field and the same grouping treatment, but the plan missed it entirely.
- **Checklist before starting**: Does this change apply to (1) HumanCharacter only, (2) Pokemon only, or (3) both? If both, plan for both upfront. Don't wait for the reviewer to catch it — they might not.

### Data Model: Don't Derive Through Optional Relationships
- Most Pokemon are wild and **unowned** (`ownerId` is null). Only trainer Pokemon have owners.
- Never assume you can derive a Pokemon field from its owner — the relationship doesn't exist for the majority of records. If Pokemon need a field (like `location`), give them their own column.
